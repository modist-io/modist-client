# -*- encoding: utf-8 -*-
# Copyright (c) 2020 Modist Team <admin@modist.io>
# ISC License <https://opensource.org/licenses/isc>

"""Contains unit-tests for the mod configuration."""

import re
import random

import pytest
from hypothesis import given, assume
from pydantic.errors import EmailError
from pydantic.networks import validate_email
from hypothesis.strategies import text, lists, characters
from pydantic.error_wrappers import ValidationError

from modist.config.mod.mod import (
    MOD_CONFIG_HOST_PATTERN,
    MOD_CONFIG_NAME_PATTERN,
    MOD_CONFIG_NAME_MAX_LENGTH,
    MOD_CONFIG_NAME_MIN_LENGTH,
    MOD_CONFIG_DESCRIPTION_MAX_LENGTH,
    MOD_CONFIG_DESCRIPTION_MIN_LENGTH,
    ModConfig,
)

from .strategies import mod_config_payload

TEST_TEXT_SAMPLE_SIZE = 12


@given(mod_config_payload())
def test_config_valid(payload: dict):
    config = ModConfig(**payload)
    assert isinstance(config, ModConfig)


@pytest.mark.extra
@given(mod_config_payload(name_strategy=text(max_size=MOD_CONFIG_NAME_MAX_LENGTH)))
def test_config_invalid_name(payload: dict):
    assume(not re.match(MOD_CONFIG_NAME_PATTERN, payload["name"]))
    with pytest.raises(ValidationError):
        ModConfig(**payload)


@pytest.mark.extra
@given(mod_config_payload(name_strategy=text(max_size=MOD_CONFIG_NAME_MIN_LENGTH - 1)))
def test_config_invalid_name_min_length(payload: dict):
    with pytest.raises(ValidationError):
        ModConfig(**payload)


@pytest.mark.extra
@pytest.mark.expensive
@given(
    mod_config_payload(
        name_strategy=text(
            min_size=MOD_CONFIG_NAME_MAX_LENGTH + 1,
            max_size=MOD_CONFIG_DESCRIPTION_MAX_LENGTH + 1,
        )
    )
)
def test_config_invalid_name_max_length(payload: dict):
    with pytest.raises(ValidationError):
        ModConfig(**payload)


@pytest.mark.extra
@given(mod_config_payload(host_strategy=text(max_size=TEST_TEXT_SAMPLE_SIZE)))
def test_config_invalid_host(payload: dict):
    assume(not re.match(MOD_CONFIG_HOST_PATTERN, payload["host"]))
    with pytest.raises(ValidationError):
        ModConfig(**payload)


@given(
    mod_config_payload(
        description_strategy=text(max_size=MOD_CONFIG_DESCRIPTION_MAX_LENGTH)
    )
)
def test_config_invalid_description_with_newline(payload: dict):
    description = payload["description"]
    index = random.randint(0, len(description))
    payload["description"] = description[:index] + "\n" + description[:index]

    with pytest.raises(ValidationError):
        ModConfig(**payload)


@pytest.mark.extra
@given(
    mod_config_payload(
        description_strategy=text(
            max_size=MOD_CONFIG_DESCRIPTION_MIN_LENGTH - 1,
            alphabet=characters(blacklist_categories=["Cc", "Zl"]),
        )
    )
)
def test_config_invalid_description_min_length(payload: dict):
    with pytest.raises(ValidationError):
        ModConfig(**payload)


@pytest.mark.extra
@pytest.mark.expensive
@given(
    mod_config_payload(
        description_strategy=text(
            min_size=MOD_CONFIG_DESCRIPTION_MAX_LENGTH + 1,
            max_size=MOD_CONFIG_DESCRIPTION_MAX_LENGTH + 1,
            alphabet=characters(blacklist_categories=["Cc", "Zl"]),
        )
    )
)
def test_config_invalid_description_max_length(payload: dict):
    with pytest.raises(ValidationError):
        ModConfig(**payload)


@given(mod_config_payload(version_strategy=text(max_size=TEST_TEXT_SAMPLE_SIZE)))
def test_config_invalid_version(payload: dict):
    with pytest.raises(ValidationError):
        ModConfig(**payload)


@pytest.mark.extra
@given(mod_config_payload(author_strategy=text(max_size=TEST_TEXT_SAMPLE_SIZE)))
def test_config_invalid_author(payload: dict):
    try:
        # NOTE: here we are explicitly ensuring that the email
        # (randomly generated by the text() strategy) is invalid
        validate_email(payload["author"])
        assume(False)
    except EmailError:
        pass

    with pytest.raises(ValidationError):
        ModConfig(**payload)


@pytest.mark.extra
@given(
    mod_config_payload(
        contributors_strategy=lists(text(max_size=TEST_TEXT_SAMPLE_SIZE), min_size=1)
    )
)
def test_config_invalid_contributors(payload: dict):

    for contributor in payload["contributors"]:
        try:
            validate_email(contributor)
            assume(False)
        except EmailError:
            break

    with pytest.raises(ValidationError):
        ModConfig(**payload)
