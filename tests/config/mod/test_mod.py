# -*- encoding: utf-8 -*-
# Copyright (c) 2020 Modist Team <admin@modist.io>
# ISC License <https://opensource.org/licenses/isc>

"""Contains unit-tests for the mod configuration."""

import re
import random
from urllib.parse import urlparse

import pytest
from pydantic import ValidationError
from hypothesis import HealthCheck, given, assume, settings
from pydantic.errors import EmailError
from pydantic.networks import validate_email
from hypothesis.strategies import text, lists, characters, from_regex

from modist.config.mod.mod import (
    MOD_CONFIG_HOST_PATTERN,
    MOD_CONFIG_NAME_PATTERN,
    MOD_CONFIG_KEYWORD_PATTERN,
    MOD_CONFIG_NAME_MAX_LENGTH,
    MOD_CONFIG_NAME_MIN_LENGTH,
    MOD_CONFIG_CATEGORY_PATTERN,
    MOD_CONFIG_KEYWORDS_MAX_LENGTH,
    MOD_CONFIG_CATEGORIES_MAX_LENGTH,
    MOD_CONFIG_DESCRIPTION_MAX_LENGTH,
    MOD_CONFIG_DESCRIPTION_MIN_LENGTH,
    ModConfig,
)

from .strategies import mod_config_payload

TEST_TEXT_SAMPLE_SIZE = 12


@given(mod_config_payload())
def test_config_valid(payload: dict):
    config = ModConfig(**payload)
    assert isinstance(config, ModConfig)


@pytest.mark.extra
@given(mod_config_payload(name_strategy=text(max_size=MOD_CONFIG_NAME_MAX_LENGTH)))
def test_config_invalid_name(payload: dict):
    assume(not re.match(MOD_CONFIG_NAME_PATTERN, payload["name"]))
    with pytest.raises(ValidationError):
        ModConfig(**payload)


@pytest.mark.extra
@given(mod_config_payload(name_strategy=text(max_size=MOD_CONFIG_NAME_MIN_LENGTH - 1)))
def test_config_invalid_name_min_length(payload: dict):
    with pytest.raises(ValidationError):
        ModConfig(**payload)


@pytest.mark.extra
@pytest.mark.expensive
@settings(suppress_health_check=(HealthCheck.too_slow,))
@given(
    mod_config_payload(
        name_strategy=text(
            min_size=MOD_CONFIG_NAME_MAX_LENGTH + 1,
            max_size=MOD_CONFIG_NAME_MAX_LENGTH + 1,
        )
    )
)
def test_config_invalid_name_max_length(payload: dict):
    with pytest.raises(ValidationError):
        ModConfig(**payload)


@pytest.mark.extra
@given(mod_config_payload(host_strategy=text(max_size=TEST_TEXT_SAMPLE_SIZE)))
def test_config_invalid_host(payload: dict):
    assume(not re.match(MOD_CONFIG_HOST_PATTERN, payload["host"]))
    with pytest.raises(ValidationError):
        ModConfig(**payload)


@given(
    mod_config_payload(
        description_strategy=text(
            max_size=MOD_CONFIG_DESCRIPTION_MAX_LENGTH,
            min_size=MOD_CONFIG_DESCRIPTION_MIN_LENGTH,
        )
    )
)
def test_config_invalid_description_with_newline(payload: dict):
    description = payload["description"]
    index = random.randint(0, len(description))
    payload["description"] = description[:index] + "\n" + description[:index]
    with pytest.raises(ValidationError):
        ModConfig(**payload)


@pytest.mark.extra
@given(
    mod_config_payload(
        description_strategy=text(
            max_size=MOD_CONFIG_DESCRIPTION_MIN_LENGTH - 1,
            alphabet=characters(blacklist_categories=["Cc", "Zl"]),
        )
    )
)
def test_config_invalid_description_min_length(payload: dict):
    with pytest.raises(ValidationError):
        ModConfig(**payload)


@pytest.mark.extra
@pytest.mark.expensive
@settings(suppress_health_check=(HealthCheck.too_slow,))
@given(
    mod_config_payload(
        description_strategy=text(
            min_size=MOD_CONFIG_DESCRIPTION_MAX_LENGTH + 1,
            max_size=MOD_CONFIG_DESCRIPTION_MAX_LENGTH + 1,
            alphabet=characters(blacklist_categories=["Cc", "Zl"]),
        )
    )
)
def test_config_invalid_description_max_length(payload: dict):
    with pytest.raises(ValidationError):
        ModConfig(**payload)


@given(mod_config_payload(version_strategy=text(max_size=TEST_TEXT_SAMPLE_SIZE)))
def test_config_invalid_version(payload: dict):
    with pytest.raises(ValidationError):
        ModConfig(**payload)


@pytest.mark.extra
@given(mod_config_payload(author_strategy=text(max_size=TEST_TEXT_SAMPLE_SIZE)))
def test_config_invalid_author(payload: dict):
    try:
        # NOTE: here we are explicitly ensuring that the email
        # (randomly generated by the text() strategy) is invalid
        validate_email(payload["author"])
        assume(False)
    except EmailError:
        pass

    with pytest.raises(ValidationError):
        ModConfig(**payload)


@pytest.mark.extra
@given(
    mod_config_payload(
        contributors_strategy=lists(text(max_size=TEST_TEXT_SAMPLE_SIZE), min_size=1)
    )
)
def test_config_invalid_contributors(payload: dict):

    for contributor in payload["contributors"]:
        try:
            validate_email(contributor)
            assume(False)
        except EmailError:
            break

    with pytest.raises(ValidationError):
        ModConfig(**payload)


@pytest.mark.extra
@given(
    mod_config_payload(
        keywords_strategy=lists(
            from_regex(MOD_CONFIG_CATEGORY_PATTERN, fullmatch=True),
            min_size=MOD_CONFIG_KEYWORDS_MAX_LENGTH + 1,
            unique=True,
        )
    )
)
def test_config_invalid_keywords_max_size(payload: dict):
    with pytest.raises(ValidationError):
        ModConfig(**payload)


@pytest.mark.extra
@given(
    mod_config_payload(
        keywords_strategy=lists(
            text(alphabet=characters(whitelist_categories=["Z"])),
            min_size=1,
            max_size=MOD_CONFIG_KEYWORDS_MAX_LENGTH,
            unique=True,
        )
    )
)
def test_config_invalid_keywords(payload: dict):
    with pytest.raises(ValidationError):
        ModConfig(**payload)


@given(
    mod_config_payload(
        keywords_strategy=lists(
            from_regex(MOD_CONFIG_KEYWORD_PATTERN, fullmatch=True),
            min_size=1,
            max_size=MOD_CONFIG_KEYWORDS_MAX_LENGTH - 1,
            unique=False,
        )
    )
)
def test_config_invalid_keywords_duplicates(payload: dict):
    payload["keywords"].append(payload["keywords"][-1])
    with pytest.raises(ValidationError):
        ModConfig(**payload)


@pytest.mark.extra
@given(
    mod_config_payload(
        categories_strategy=lists(
            from_regex(MOD_CONFIG_CATEGORY_PATTERN, fullmatch=True),
            min_size=MOD_CONFIG_CATEGORIES_MAX_LENGTH + 1,
            unique=True,
        )
    )
)
def test_config_invalid_categories_max_size(payload: dict):
    with pytest.raises(ValidationError):
        ModConfig(**payload)


@pytest.mark.extra
@given(
    mod_config_payload(
        categories_strategy=lists(
            text(alphabet=characters(whitelist_categories=["Z"])),
            min_size=1,
            max_size=MOD_CONFIG_CATEGORIES_MAX_LENGTH,
            unique=True,
        )
    )
)
def test_config_invalid_categories(payload: dict):
    with pytest.raises(ValidationError):
        ModConfig(**payload)


@given(
    mod_config_payload(
        categories_strategy=lists(
            from_regex(MOD_CONFIG_CATEGORY_PATTERN, fullmatch=True),
            min_size=1,
            max_size=MOD_CONFIG_CATEGORIES_MAX_LENGTH - 1,
            unique=False,
        )
    )
)
def test_config_invalid_categories_duplicates(payload: dict):
    payload["categories"].append(payload["categories"][-1])
    with pytest.raises(ValidationError):
        ModConfig(**payload)


@pytest.mark.extra
@given(mod_config_payload(homepage_strategy=text()))
def test_config_invalid_homepage(payload: dict):
    try:
        # NOTE: because we are utilizing an HttpUrl for the homepage field, the easiest
        # way of ensuring some text violates the homepage validation is to make sure the
        # scheme is not provided
        if len(urlparse(payload["homepage"]).scheme) > 0:
            assume(False)
    except ValueError:
        pass

    with pytest.raises(ValidationError):
        ModConfig(**payload)
